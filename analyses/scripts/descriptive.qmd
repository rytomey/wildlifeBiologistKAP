---
title: "Descriptive statistics"
date: "`r Sys.Date()`"
format: 
  html:
    html-table-processing: none
    toc: true
    toc-depth: 4
    toc-location: left
    number-sections: true
    code-fold: true
    code-summary: "Show Code"
    fig-cap-location: bottom
    smooth-scroll: true
    theme: flatly
    font-family: serif
    font-size: 12px
    line-height: 150%
    css: styles.css  # Reference your CSS file here
---

# Initialization

```{r include=FALSE}

require(dplyr)
require(sf)
require(sp)
require(tidyverse)
require(tidyterra)
require(terra)
require(ggplot2)
require(knitr)
require(gt)
require(scales)
require(rlang)
require(zipcodeR)
require(tidyr)
require(stringr)

```

```{r}

##### Create CSS file for scientific table format ####
cat("
.styled-table {
    width: 100%;
    border-collapse: collapse;
    font-family: serif;
    font-size: 12pt;
    color: black; /* Ensures all text is black */
}
.styled-table thead {
    background-color: #ffffff;
    font-weight: bold;
    border-bottom: 2px solid black;
    color: black; /* Ensures header text is black */
}
.styled-table th {
    font-weight: bold; /* Ensures column names are bold */
}
.styled-table th, .styled-table td {
    padding: 8px;
    text-align: center;
}
.styled-table tbody tr:nth-child(odd) {
    background-color: #ffffff;
}
.styled-table tbody tr:hover {
    background-color: #ffffff;
}
.styled-table td {
    border-bottom: 1px solid #ddd;
}
", file = "styles.css")

```

### Importing Data

```{r include=FALSE}

# setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
base = normalizePath(file.path("..", ".."), mustWork = FALSE)  
analyses = file.path(base, "analyses")
inp = file.path(analyses, "inputs")
surv = read.csv(file.path(inp, "progover60.csv"))
surv # 155 responses with over 50% of questions answered

```

# Processing

```{r}

########## Calculating Age ############
surv$AGE = 2024 - surv$DOB

########## Converting DURATION to minutes ############
surv$DURATIONMIN <- surv$DURATION / 60

########### Adding Respondent County ############
zip_info <- zipcodeR::zip_code_db %>%
  select(zipcode, county, state)

surv <- surv %>%
  mutate(ZIPCODE = as.character(ZIPCODE)) %>%
  left_join(zip_info, by = c("ZIPCODE" = "zipcode"))
surv <- surv %>% select(-state)
names(surv)[names(surv) == "county"] <- "COUNTY"

########### Converting Health Knowledge to Correct/surv ###########
answers <- list(
  PIGS       = "True",       
  BRUCE      = "False",      
  CWD        = "False",      
  FLUAL      = "True",       
  FLU        = "False",      
  COVID      = "True",       
  COVIDSPILL = "False",      
  RABIESAL   = "False",      
  RABIES     = "Bites",      
  TURKEY     = "Incinerate" 
)

for (q in names(answers)) {
  response_clean <- tolower(trimws(as.character(surv[[q]])))
  correct_clean <- tolower(trimws(answers[[q]]))
  
  # CERTAIN: 1 if not "i don't know", else 0
  surv[[paste0(q, "CERTAIN")]] <- ifelse(response_clean == "i don't know", 0, 1)
  
  # CORRECT: 1 if correct, 0 otherwise (including "i don't know")
  surv[[paste0(q, "CORRECT")]] <- ifelse(response_clean == correct_clean, 1, 0)
  
  # CCORRECT: 1 if correct, 0 if incorrect, NA if "i don't know"
  surv[[paste0(q, "CCORRECT")]] <- ifelse(response_clean == "i don't know", NA,
                                    ifelse(response_clean == correct_clean, 1, 0))
}

# Row totals
surv$CORRECT <- rowSums(surv[, paste0(names(answers), "CORRECT")], na.rm = TRUE)
surv$CERTAIN <- rowSums(surv[, paste0(names(answers), "CERTAIN")], na.rm = TRUE)
surv$CCORRECT <- rowSums(surv[, paste0(names(answers), "CCORRECT")], na.rm = TRUE)

correct_cols <- paste0(names(answers), "CORRECT")
ccorrect_cols <- paste0(names(answers), "CCORRECT")
certain_cols <- paste0(names(answers), "CERTAIN")
surv$CORRECT <- rowSums(surv[, correct_cols], na.rm = TRUE)
surv$CCORRECT <- rowSums(surv[, ccorrect_cols], na.rm = TRUE)
surv$CERTAIN <- rowSums(surv[, certain_cols], na.rm = TRUE)

########## Recoding Neutral Attitudes #############
attitude_columns <- c(
  "CWDAL", "BATS", "EDREQ", "INFO", "HANDSON", "PPEREQ",
  "EHD", "DARWIN", "POPRED", "POPPLAN", "SURVEY",
  "VACCINE", "PREVAL", "DIVERSE", "CONSEQ", "CLIMATE"
)

surv <- surv %>%
  mutate(across(all_of(attitude_columns), ~ case_when(
    .x == "Neutral" ~ 0,
    !is.na(.x) ~ 1,
    TRUE ~ NA_real_), .names = "{.col}NEUTRAL"))
binary_columns <- paste0(attitude_columns, "NEUTRAL")

surv <- surv %>% # total number of neutral attitudes per respondent
  mutate(
    NEUTRAL = rowSums(across(all_of(binary_columns), ~ .x == 0), na.rm = TRUE))

######## Looked / Not for health info ############
surv <- surv %>%
  mutate(noSOURCE = case_when(
    is.na(SOURCE) ~ NA_real_,
    str_detect(SOURCE, fixed("I have Not looked for health information")) ~ 0,
    TRUE ~ 1
  ))
table(surv$SOURCE)
table(surv$noSOURCE)

######### Interest in education certainty ###########
surv <- surv %>%
  mutate(INTERESTCERTAIN = case_when(
    INTEREST == "Unsure" ~ 0,
    INTEREST %in% c("Yes", "No") ~ 1,
    TRUE ~ NA_real_
  ))
table(surv$INTEREST)
table(surv$INTERESTCERTAIN)

########## Count of Selections (multiple selections) ###############
# for each option
selFUN <- function(df, column_name, delimiter = ",") {
  df %>%
    select({{ column_name }}) %>%
    filter(!is.na({{ column_name }})) %>%
    mutate(response = str_split({{ column_name }}, pattern = delimiter)) %>%
    unnest(response) %>%
    mutate(response = str_trim(response)) %>%
    count(response, sort = TRUE, name = "Count")
}

# for each response
sel2FUN <- function(df, columns, delimiter = ",") {
  for (colname in columns) {
    df[[paste0(colname, "sel2")]] <- ifelse(
      is.na(df[[colname]]),
      0,
      str_count(df[[colname]], fixed(delimiter)) + 1
    )
  }
  return(df)
}
surv <- sel2FUN(surv, columns = c("TOPICS", "SOURCE", "COUNTIES", "FREEINFO"))

```

# Functions

### Basic Summary Stats (Cont/Cat)

```{r}

sumFUN <- function(df) {
  summary_list <- list()
  
  for (colname in names(df)) {
    column <- df[[colname]]
    
    if (is.numeric(column)) {
 # Continuous variable summary
      summary_list[[colname]] <- tibble::tibble(
        Variable = colname,
        Type = "Continuous",
        N = sum(!is.na(column)),
        Mean = mean(column, na.rm = TRUE),
        Median = median(column, na.rm = TRUE),
        SD = sd(column, na.rm = TRUE),
        Min = min(column, na.rm = TRUE),
        Max = max(column, na.rm = TRUE)
      )
    } else if (is.factor(column) || is.character(column) || is.logical(column)) {
 # Categorical variable summary
      freq_table <- as.data.frame(table(column, useNA = "ifany"))
      names(freq_table) <- c("Level", "Count")
      freq_table$Variable <- colname
      freq_table$Proportion <- freq_table$Count / sum(freq_table$Count)
      freq_table <- freq_table[, c("Variable", "Level", "Count", "Proportion")]
      summary_list[[colname]] <- freq_table
    }
  }
  return(summary_list)
}

survsum <- sumFUN(surv)

```

### Response Count (for numeric columns)

```{r}

uniFUN <- function(df, columns = NULL) {
  if (is.null(columns)) {
    columns <- names(df)
  }
  list <- list()
  for (col in columns) {
    if (col %in% names(df)) {
      list[[col]] <- df %>%
        count(!!sym(col), name = "Count") %>%
        arrange(desc(Count))
    } else {
      warning(paste("Column", col, "not found in data."))
    }
  }
  return(list)
}

survuni = uniFUN(surv)

```

# Qualtrics Metadata

```{r}
######## BASIC ##########
survsum$DURATION
survsum$DURATIONMIN
survsum$FINISHED
survsum$PROG
survsum$QSCORE
survsum$FINISHED
survsum$RECDATE

######## RESPONSE COUNT ##########
survuni$RECDATE
survuni$PROG
survuni$DURATIONMIN

```

```{r}

##### PROGRESS grouped by 10% intervals #######
intFUN <- function(df, column = "PROG") {
  require(dplyr)

  df %>%
    mutate(
      prog_bin = cut(
        !!sym(column),
        breaks = seq(0, 100, by = 10),
        include.lowest = TRUE,
        right = FALSE,
        labels = paste0(seq(0, 90, 10), "-", seq(10, 100, 10), "%")
      )
    ) %>%
    count(prog_bin, name = "Respondent_Count") %>%
    arrange(prog_bin)
 }

PROGint = intFUN(surv)
PROGint

###### Duration (min) grouped by 10 minute intervals ###########
max_min <- ceiling(max(surv$DURATIONMIN, na.rm = TRUE) / 10) * 10
breaks <- seq(0, max_min, by = 10)
labels <- paste0(head(breaks, -1), "-", tail(breaks, -1), " min")
surv$DURATIONBIN <- cut(
  surv$DURATIONMIN,
  breaks = breaks,
  right = FALSE,
  include.lowest = TRUE,
  labels = labels
)
DURbin <- surv %>%
  count(DURATIONBIN, name = "Respondent_Count") %>%
  arrange(DURATIONBIN)
print(DURbin)
surv <- surv %>% select(-DURATIONBIN)

```

# Demographics

```{r}

######## BASIC ##########
survsum$AGE
survsum$DOB
survsum$GENDER
survsum$RACE
survsum$ETHNICITY
survsum$INCOME
survsum$COUNTY
survsum$ACCESS


######## RESPONSE COUNT ##########
survuni$AGE
survuni$DOB

```

# Education & Experience

```{r}

######## BASIC ##########
survsum$EDUCATION
survsum$DEGREE
survsum$TWS
survsum$COURSE
survsum$COURSETIME
survsum$SELFTITLE
survsum$BIOTIME
survsum$ACTIVITYfill
survsum$othACTIVITY
survsum$AFFILIATEfill
survsum$othAFFILIATE

```

# Practices & Activities

```{r}

######## BASIC ##########
survsum$CONTACT
survsum$FIELD
survsum$COLLECT
survsum$HANDLE
survsum$STATE
survsum$PPE
survsum$PPETIME
survsum$COUNTIES
survsum$LICENSE

##### Selection Count / Answer Options ########
# Numver of selections per response option
SOURCEsel = selFUN(surv, SOURCE)
SOURCEsel
survsum$othSOURCE
COUNTIESsel = selFUN(surv, COUNTIES)
COUNTIESsel

# Number of options selected per respondent 
survsum$SOURCEsel2
survuni$SOURCEsel2
survsum$COUNTIESsel2
survuni$COUNTIESsel2


```

# Health Knowledge

```{r}

######## BASIC ##########
survsum$PIGS
survsum$BRUCE
survsum$CWD
survsum$FLUAL
survsum$COVID
survsum$COVIDSPILL
survsum$RABIESAL
survsum$RABIES
survsum$TURKEY

####### CORRECT ########
# I don't know = 0
survuni$PIGSCORRECT
survuni$BRUCECORRECT
survuni$CWDCORRECT
survuni$FLUALCORRECT
survuni$COVIDCORRECT
survuni$COVIDSPILLCORRECT
survuni$RABIESALCORRECT
survuni$RABIESCORRECT
survuni$TURKEYCORRECT
survuni$CORRECT # I don't know responses = 0

# I don't know = NA
survuni$PIGSCCORRECT
survuni$BRUCECCORRECT
survuni$CWDCCORRECT
survuni$FLUALCCORRECT
survuni$COVIDCCORRECT
survuni$COVIDSPILLCCORRECT
survuni$RABIESALCCORRECT
survuni$RABIESCCORRECT
survuni$TURKEYCCORRECT
survuni$CCCORRECT # I don't know responses removed


####### CERTAIN ########
survuni$PIGSCERTAIN
survuni$BRUCECERTAIN
survuni$CWDCERTAIN
survuni$FLUALCERTAIN
survuni$COVIDCERTAIN
survuni$COVIDSPILLCERTAIN
survuni$RABIESALCERTAIN
survuni$RABIESCERTAIN
survuni$TURKEYCERTAIN
survuni$CERTAIN

```

# Attitudes & Beliefs

```{r}

######## BASIC ##########
survsum$CWDAL
survsum$BATS
survsum$PPEREQ
survsum$EHD
survsum$DARWIN
survsum$POPRED
survsum$POPPLAN
survsum$SURVEY
survsum$VACCINE
survsum$PREVAL
survsum$DIVERSE
survsum$CONSEQ
survsum$CLIMATE

###### HEALTH EDUCATION ######
survuni$noSOURCE
survsum$EDREQ
survsum$INFO
survsum$HANDSON
survsum$INTEREST
survuni$INTERESTCERTAIN
survsum$othTOPICS
survsum$othFREEINFO

##### Selection Count #########
# Number of responses per response
TOPICSsel = selFUN(surv, TOPICS)
TOPICSsel
survsum$othTOPICS
FREEINFOsel = selFUN(surv, FREEINFO)
FREEINFOsel
survsum$othFREEINFO

# Number of responses per respondent 
survsum$TOPICSsel2
survuni$TOPICSsel2
survsum$FREEINFOsel2
survuni$FREEINFOsel2

######## Neutrality ##############
survuni$CWDALNEUTRAL
survuni$BATSNEUTRAL
survuni$PPEREQNEUTRAL
survuni$EHDNEUTRAL
survuni$DARWINNEUTRAL
survuni$POPREDNEUTRAL
survuni$POPPLANNEUTRAL
survuni$SURVEYNEUTRAL
survuni$VACCINENEUTRAL
survuni$PREVALNEUTRAL
survuni$DIVERSENEUTRAL
survuni$CONSEQNEUTRAL
survuni$CLIMATENEUTRAL
survuni$EDREQNEUTRAL
survuni$INFONEUTRAL
survuni$HANDSONNEUTRAL
survsum$NEUTRAL
survuni$NEUTRAL

```

# Write CSV

```{r}
#| include: false

###### Processed Responses ######
oup = file.path(analyses, "outputs")
write.csv(surv, file.path(oup, "descriptiveKAP.csv"), row.names = FALSE)

```

```{r}
#| echo: false

##### CSS Tables #####
# kable(RSCOUNTIES, format = "html", table.attr = "class='styled-table'", align = "c")

```

## Technical Refs

```{r bib}
#| echo: false

#### To write a bib file
# knitr::write_bib(sub("^package:", "", grep("package", search(), value=TRUE)), file='pckg.bib')

#### to display the packages within the .qmd without creating another .bib ####
knitr::write_bib(sub("^package:", "", grep("package", search(), value=TRUE)), file='')

```
